# Real-time Updates Implementation

## ⚠️ ВАЖНО: Требуется включение Realtime репликации

**Перед использованием убедитесь, что Realtime репликация включена для таблиц.**

См. подробную инструкцию в файле **[REALTIME_FIX.md](./REALTIME_FIX.md)**

Если real-time обновления не работают (требуется обновление страницы):
1. Проверьте, что таблицы добавлены в `supabase_realtime` publication
2. Примените миграцию из REALTIME_FIX.md
3. Перезагрузите страницу

## Обзор

Реализована система real-time обновлений для уведомлений, приглашений в команды и заявок в команды с использованием Supabase Realtime.

## Архитектура

### Хуки Real-time

Все real-time хуки расположены в `src/hooks/`:

1. **`useRealtimeNotifications.ts`**
   - Подписывается на изменения в таблице `notifications`
   - Фильтр: `user_id=eq.{userId}`
   - Инвалидирует: `["notifications"]`, `["notifications-count"]`

2. **`useRealtimeTeamInvitations.ts`**
   - Подписывается на изменения в таблице `team_invitations`
   - Два режима:
     - Для игрока: фильтр `invited_user_id=eq.{userId}`
     - Для менеджера команды: фильтр `team_id=eq.{teamId}` (для каждой управляемой команды)
   - Инвалидирует: `["my-team-invites"]`, `["team-invites-sent"]`, `["notifications-count"]`

3. **`useRealtimeTeamApplications.ts`**
   - Подписывается на изменения в таблице `team_applications`
   - Два режима:
     - Для заявителя: фильтр `applicant_id=eq.{userId}`
     - Для менеджера команды: фильтр `team_id=eq.{teamId}` (для каждой управляемой команды)
   - Инвалидирует: `["my-team-applications"]`, `["team-applications"]`, `["team-applications-count"]`, `["notifications-count"]`

### Интеграция в UI

Хуки интегрированы в следующие компоненты:

- **`TopBar.tsx`**: Real-time обновления счетчика уведомлений
- **`NotificationsDialog.tsx`**: Real-time обновления приглашений и заявок игрока
- **`TeamApplicationsTab.tsx`**: Real-time обновления заявок и приглашений команды
- **`Sidebar.tsx`**: Real-time обновления счетчика заявок для менеджеров команд

## RLS Политики

### notifications
- SELECT: `user_id = auth.uid()` — пользователь видит только свои уведомления
- INSERT: `true` — система может создавать уведомления
- UPDATE: `user_id = auth.uid()` — пользователь может отмечать прочитанными только свои

### team_invitations
- SELECT:
  - `invited_user_id = auth.uid()` — приглашенный видит свои приглашения
  - `is_team_manager(team_id)` — менеджер команды видит приглашения своей команды
- INSERT: `is_team_manager(team_id)` — только менеджеры могут создавать приглашения
- UPDATE: 
  - `invited_user_id = auth.uid()` — приглашенный может принять/отклонить
  - `is_team_manager(team_id)` — менеджер может отменить
- DELETE: `is_team_manager(team_id)` — менеджер может отменить

### team_applications
- SELECT:
  - `applicant_id = auth.uid()` — заявитель видит свои заявки
  - `is_team_manager(team_id)` — менеджер команды видит заявки в свою команду
- INSERT: `applicant_id = auth.uid()` — пользователь может создать заявку
- UPDATE: `is_team_manager(team_id)` — только менеджеры могут менять статус
- DELETE: `applicant_id = auth.uid()` — заявитель может удалить свою заявку

## Принцип работы

1. **Подписка на изменения**
   - При монтировании компонента создается Supabase Realtime channel
   - Channel подписывается на события INSERT/UPDATE/DELETE для конкретной таблицы
   - Применяется фильтр для получения только релевантных событий

2. **Обработка событий**
   - При получении события (любого типа: INSERT, UPDATE, DELETE)
   - Вызывается `queryClient.invalidateQueries()` для соответствующих query keys
   - React Query автоматически перезапрашивает данные
   - UI обновляется с новыми данными

3. **Очистка**
   - При размонтировании компонента все channels удаляются через `supabase.removeChannel()`
   - Предотвращает утечки памяти и дублирование подписок

## Безопасность

- Все Realtime события проходят через RLS политики
- Пользователь получает события только для данных, к которым у него есть SELECT доступ
- Фильтры на уровне Realtime дополнительно ограничивают поток событий
- Не требуется дополнительная валидация на клиенте

## Тестирование

### Сценарий A: Капитан приглашает игрока
1. Браузер 1: капитан отправляет приглашение
2. Браузер 2: игрок видит приглашение мгновенно без обновления страницы
3. Проверка: badge с количеством уведомлений обновляется

### Сценарий B: Игрок подает заявку
1. Браузер 1: игрок отправляет заявку в команду
2. Браузер 2: капитан/тренер видит заявку мгновенно
3. Проверка: список заявок и счетчики обновляются

### Сценарий C: Обновление статуса
1. Капитан принимает/отклоняет заявку или приглашение
2. Игрок видит изменение статуса мгновенно
3. Проверка: все связанные UI элементы обновлены

## Производительность

- Используется стратегия инвалидации запросов вместо прямого обновления кэша
- Простая и надежная реализация, минимальный риск рассинхронизации
- React Query управляет дедупликацией и оптимизацией запросов
- Минимальное количество подписок: 1-3 канала на пользователя в зависимости от роли

## Улучшения (опционально)

В будущем можно оптимизировать производительность:
- Прямое обновление кэша React Query вместо инвалидации
- Оптимистичные обновления UI
- Батчинг множественных инвалидаций
- Более гранулярные query keys для точечных обновлений

